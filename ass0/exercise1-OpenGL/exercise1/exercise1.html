<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Exercise 1: Intro to OpenGL</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {  background-color: #f8f8f8; }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ef2929; } /* Alert */
    code span.an { color: #8f5902; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #c4a000; } /* Attribute */
    code span.bn { color: #0000cf; } /* BaseN */
    code span.cf { color: #204a87; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4e9a06; } /* Char */
    code span.cn { color: #000000; } /* Constant */
    code span.co { color: #8f5902; font-style: italic; } /* Comment */
    code span.cv { color: #8f5902; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #8f5902; font-weight: bold; font-style: italic; } /* Documentation */
    code span.dt { color: #204a87; } /* DataType */
    code span.dv { color: #0000cf; } /* DecVal */
    code span.er { color: #a40000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #0000cf; } /* Float */
    code span.fu { color: #000000; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #8f5902; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #204a87; font-weight: bold; } /* Keyword */
    code span.op { color: #ce5c00; font-weight: bold; } /* Operator */
    code span.ot { color: #8f5902; } /* Other */
    code span.pp { color: #8f5902; font-style: italic; } /* Preprocessor */
    code span.sc { color: #000000; } /* SpecialChar */
    code span.ss { color: #4e9a06; } /* SpecialString */
    code span.st { color: #4e9a06; } /* String */
    code span.va { color: #000000; } /* Variable */
    code span.vs { color: #4e9a06; } /* VerbatimString */
    code span.wa { color: #8f5902; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <style>
/*
 * Slightly modified version of the following theme:;
 * https://github.com/markdowncss/air
 */
 html {
  font-size: 12px;
}

@media print {
  *:before,
  *:after {
    background: transparent !important;
    color: #000 !important;
    box-shadow: none !important;
    text-shadow: none !important;
  }

  html {
    font-size: 12px;
  }
  body {
    padding-left: 4rem;
    padding-right: 4rem;
  }

  a,
  a:visited {
    text-decoration: underline;
  }

  a[href]:after {
    content: " (" attr(href) ")";
  }

  abbr[title]:after {
    content: " (" attr(title) ")";
  }

  a[href^="#"]:after,
  a[href^="javascript:"]:after {
    content: "";
  }

  pre,
  blockquote {
    border: 1px solid #999;
    page-break-inside: avoid;
  }

  thead {
    display: table-header-group;
  }

  tr,
  img {
    page-break-inside: avoid;
  }

  p,
  h2,
  h3 {
    orphans: 3;
    widows: 3;
  }

  h2,
  h3 {
    page-break-after: avoid;
  }
}

@media screen and (min-width: 32rem) and (max-width: 48rem) {
  html {
    font-size: 12px;
  }
}

@media screen and (min-width: 48rem) {
  html {
    font-size: 12px;
  }
}

body {
  line-height: 1.85;
  padding-bottom: 2rem;
}

hr {
  border-width: 0.1px;
  border-color: #777;
}

p,
.air-p {
  font-size: 1rem;
  margin-bottom: 1.3rem;
}

h1,
.air-h1,
h2,
.air-h2,
h3,
.air-h3,
h4,
.air-h4 {
  margin: 1.414rem 0 .5rem;
  font-weight: inherit;
  line-height: 1.42;
}

h1,
.air-h1 {
  /* margin-top: 0; */
  font-size: 1.875rem;
  width: 100%;
  margin-bottom: 1em;
  padding-bottom: 0.3em;
  border-bottom: 0.1px solid #777;
}


h2,
.air-h2 {
  font-size: 1.6rem;
  width: 100%;
  padding-bottom: 0.3em;
  border-bottom: 0.1px solid #777;
}

h3,
.air-h3 {
  font-size: 1.25rem;
}

h4,
.air-h4 {
  font-size: 1.2rem;
}

h5,
.air-h5 {
  font-size: 1.121rem;
}

h6,
.air-h6 {
  font-size: .88rem;
}

small,
.air-small {
  font-size: .707em;
}

/* https://github.com/mrmrs/fluidity */

img,
canvas,
iframe,
video,
svg,
select,
textarea {
  display: inline;
  margin-left: auto;
  margin-right: auto;
  max-width: 100%;
}

figcaption {
  text-align: center;
}
.subfigures {
  text-align: center;
}
.subfigures figure {
  float: left;
  width: 50%;
  margin:0;
  display: inline-block;
}
.subfigures img {
  display: inline-block;
  width: 90%;
}
.subfigures figure figcaption {
  display: inline-block;
}

@import url(http://fonts.googleapis.com/css?family=Open+Sans:300italic,300);

body {
  color: #444;
  font-family: 'Open Sans', Helvetica, sans-serif;
  font-weight: 300;
  margin: 6rem auto 1rem;
  max-width: 58rem;
  text-align: left;
  /* text-align: justify; */
}

/*img {
  border-radius: 50%;
  height: 200px;
  margin: 0 auto;
  width: 200px;
}*/

a,
a:visited {
  color: #3498db;
}

a:hover,
a:focus,
a:active {
  color: #2980b9;
}

pre:not(.sourceCode) {
  background-color: #fafafa;
}
pre {
  padding: 1rem;
  text-align: left;
}

blockquote {
  margin: 0;
  border-left: 5px solid #7a7a7a;
  font-style: italic;
  padding: 1.33em;
  text-align: left;
}

ul,
ol,
li {
  text-align: left;
}

p {
  /* color: #777; */
}

/*
 * Copied from w3schools.com:
 * https://www.w3schools.com/css/css_table.asp
 *
 * Table header colour changed to CGV home style (taken from CGV Powerpoint template)
 */
table {
  border-collapse: collapse;
  width: 100%;
}
table td, table th {
  border: 1px solid #ddd;
  padding: 2px 4px;
}
table tr:nth-child(even){background-color: #f2f2f2;}
table th {
  padding: 2px 4px;
  text-align: left;
  background-color: #f2f2f2;
  color: black;
}


</style>
  <div style="overflow:auto;">
  	<p style="float:left;margin:0;"><b>CS4515</b> -3D Computer Graphics and Animation</p><p style="float:right;margin:0;">Elmar Eisemann, Ricardo Marroquim</p>
  </div>

  <hr>
  <br/>
</head>
<body>
<header id="title-block-header">
<h1 class="title">Exercise Set 1: Intro to OpenGL</h1>
</header>
<p>Welcome to 3DCGA! In these first exercises of the course, you will learn the basics of graphics programming with Legacy OpenGL, and you will get some hands-on experience with using the <code>glm</code> library for working with 3D transformations.</p>
<p>These exercises comes with a corresponding C++ code template, which is heavily commented with instructions on what to implement. The <code>main.cpp</code> file contains five functions left blank which you will implement throughout these exercises.</p>
<h2 id="background-imgui">Background: <code>ImGui</code></h2>
<p>This, and the following exercises and assignments use the <a href="https://github.com/ocornut/imgui">Dear ImGui</a> library for creating interactive UIs. When you run the program you should see a UI window with some controls. The window can be hidden/shown by pressing the backtick (<code>`</code>) key.</p>
<p>The layout of this UI window is declared in the <code>imgui</code> function in <code>main.cpp</code>, and you are free to modify it in this, and the following assignments to create useful widgets to control and debug the live state of your applications. We have also included some dummy controls that you can use as a base for implementing your custom controls.</p>
<h2 id="background-rendering-with-legacy-opengl">Background: Rendering with legacy OpenGL</h2>
<p>In this exercise, we will use the legacy OpenGL (version 2.1) commands for rendering 3D shapes to the screen. In later assignments, we will cover the more complex, but more flexible modern OpenGL pipeline.</p>
<p>To draw a primitive shape, such as a triangle, we need to specify its properties in a<code>glBegin(PRIMITIVE_ID)</code>/<code>glEnd()</code> block. For example, to render a triangle, you can write:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a>glBegin(GL_TRIANGLES);</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a>glVertex3f(x0, y0, z0);</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a>glVertex3f(x1, y1, z1);</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a>glVertex3f(x2, y2, z2);</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a>glEnd()</span></code></pre></div>
<p>Additionally, you can set properties for the entire primitive before rendering, such as color and normal to modify the properties of the primitive.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a>glColor3f(<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>);</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a>glNormal3f(<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>);</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a>glBegin(GL_TRIANGLES);</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a><span class="co">// ...</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a>glEnd();</span></code></pre></div>
<p>We don’t need much more for the sake of this exercise, but for more information, see the <a href="http://15462.courses.cs.cmu.edu/spring2018content/lectures/00_opengl/00_opengl_slides.pdf">CMU OpenGL Tutorial</a>.</p>
<h1 id="exercise-1-triangle">Exercise 1: Triangle</h1>
<p>In this exercise, you will implement basic triangle rendering by implementing the <code>drawTriangle</code> function. The function should:</p>
<ol type="1">
<li>Render a triangle with arbitrary vertex positions</li>
<li>Add a second triangle in Blue, and make both triangles share their first vertex</li>
<li>Add a global variable (initialized to 0) that represents the x-coordinate of the first vertex of each triangle</li>
<li>Go to the function <code>animate</code> and increment this variable by a small value on each iteration, observe the animation, alternatively you can control this value with an ImGui widget</li>
</ol>
<h2 id="background-glm-opengl-math-library">Background: GLM OpenGL Math Library</h2>
<p>In this exercise we use <a href="https://openframeworks.cc/documentation/glm/"><code>glm</code></a> as a library for working with linear algebra. <code>glm</code> provides classes for common mathematical objects and operations such as vectors, and matrices:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="co">// Declare a 3-vector</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a>glm::vec3 vector = glm::vec3(<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>);</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a><span class="co">// create the 3x3 identity matrix</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true"></a>glm::mat3 identity = glm::mat3(<span class="fl">1.0</span><span class="bu">f</span>)</span></code></pre></div>
<p>Additionally, glm provides a lot of functions for working with these objects, and overloads their operators allowing us to perform arithmetic with them:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="co">// create a matrix with 2 on diagonals</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a>glm::mat3 scaleMatrix = <span class="dv">2</span> * identity;</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a><span class="co">// multiply the vector with the matrix</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true"></a>glm::scaledVector = vector * scaleMatrix;</span></code></pre></div>
<p>In this exercise, you will mostly work with <code>glm::vec3</code> objects for representing 3D points and vectors,<code>glm:vec4</code> objects for representing points and vectors in homogeneous space, and <code>glm::mat4</code> matrices for representing and applying 3D translations, and rotations and scales on these points.</p>
<p>To construct transformation matrices, GLM provides the useful <code>rotate</code>, <code>translate</code>, and <code>scale</code>. They each take a base matrix as input, and a series of arguments specifying the parameters of the rotation/translation/scale and output the matrix that first applies the base transform, and then the specified one:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="co">// initialize matrix as identity</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a>glm::mat4 transform = glm::mat4(<span class="fl">1.0</span><span class="bu">f</span>);</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true"></a><span class="co">// define translation, rotation, and scale</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true"></a>glm::vec3 translationVector(<span class="fl">10.0</span><span class="bu">f</span>, <span class="fl">5.0</span><span class="bu">f</span>, <span class="fl">2.0</span><span class="bu">f</span>);  <span class="co">// translate by (10, 5, 2)</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true"></a>glm::vec3 scaleVector(<span class="fl">2.0</span><span class="bu">f</span>, <span class="fl">2.0</span><span class="bu">f</span>, <span class="fl">2.0</span><span class="bu">f</span>);         <span class="co">// scale by a factor of 2 on all axes</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true"></a>glm::vec3 rotationAxis(<span class="fl">0.0</span><span class="bu">f</span>, <span class="fl">1.0</span><span class="bu">f</span>, <span class="fl">0.0</span><span class="bu">f</span>);        <span class="co">// rotate around the y-axis</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true"></a><span class="dt">float</span> rotationAngle = glm::radians(<span class="fl">45.0</span><span class="bu">f</span>);       <span class="co">// rotate by 45 degrees</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true"></a></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true"></a><span class="co">// apply scaling</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true"></a>transform = glm::scale(transform, scaleVector);</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true"></a></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true"></a><span class="co">// apply rotation</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true"></a>transform = glm::rotate(transform, rotationAngle, rotationAxis);</span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true"></a></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true"></a><span class="co">// apply translation</span></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true"></a>transform = glm::translate(transform, translationVector);</span></code></pre></div>
<p>Alternatively, you can separately construct the translation, rotation and scale matrices by passing the identity matrix as the base matrix, and then multiply them in reverse order at the end to obtain the equivalent composed transform matrix:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a>glm::mat4 id = glm::vec4(<span class="fl">1.0</span><span class="bu">f</span>);</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a>glm::mat4 scaleMatrix = glm::scale(id, scaleVector);</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a>glm::mat4 rotationMatrix = glm::rotate(id, rotationAngle, rotationAxis);</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true"></a>glm::mat4 translationMatrix = glm::translate(id, translationVector);</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true"></a></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true"></a><span class="co">// combine the matrices by multiplying in reverse order</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true"></a>glm::mat4 transform = translationMatrix * rotationMatrix * scaleMatrix;</span></code></pre></div>
<h1 id="exercise-2-render-a-unit-face">Exercise 2: Render a Unit Face</h1>
<p>Implement the function <code>drawUnitFace</code>. This function should render a 1x1 quad to the screen. You can use the <code>GL_QUADS</code> primitive, which works like the triangle primitive but with a fourth vertex:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a>glBegin(GL_QUADS);</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a>glVertex3f(x1, y1, z1);</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a>glVertex3f(x2, y2, z2);</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true"></a>glVertex3f(x3, y3, z3);</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true"></a>glVertex3f(x4, y4, z4);</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true"></a>glEnd();</span></code></pre></div>
<p>Additionally, the function takes a <code>transformMatrix</code> argument, which represents a glm 4x4 transform matrix. Modify your implementation so that the quad is transformed according to this matrix.</p>
<h1 id="exercise-3-render-a-unit-cube">Exercise 3: Render a Unit Cube</h1>
<p>Implement the function <code>drawUnitCube</code>. This function should render a 1x1x1 cube to the screen.</p>
<p>If you have implemented the previous exercise correctly, the most straightforward implementation is to call <code>drawUnitFace</code> 6 times, once for each face, passing different transform matrices for each call such that they make up a cube.</p>
<p>Additionally, like the previous exercise, this function takes a transform matrix that should be applied to the whole cube. Modify your implementation so that the cube is transformed according to this matrix.</p>
<h1 id="exercise-4-render-an-animated-robot-arm.">Exercise 4: Render an animated robot arm.</h1>
<p>Implement the function <code>drawArm</code>. This function should render a three-unit arm with an upper arm, forearm, and hand, each represented by a cube, and three joints representing the shoulder, elbow, and wrist rotations.</p>
<p>Your robot arm should be controllable with two global variables:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a><span class="co">// scale vector of each part of the arm determines the arm shape</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a><span class="at">const</span> <span class="bu">std::</span>array armScale {</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a>    glm::vec3(<span class="fl">0.5</span><span class="bu">f</span>, <span class="fl">0.5</span><span class="bu">f</span>, <span class="fl">1.0</span><span class="bu">f</span>),</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true"></a>    glm::vec3(<span class="fl">0.3</span><span class="bu">f</span>, <span class="fl">0.3</span><span class="bu">f</span>, <span class="fl">0.8</span><span class="bu">f</span>),</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true"></a>    glm::vec3(<span class="fl">0.6</span><span class="bu">f</span>, <span class="fl">0.6</span><span class="bu">f</span>, <span class="fl">0.6</span><span class="bu">f</span>)</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true"></a>};</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true"></a></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true"></a><span class="co">// rotation of each part of the arm, determines the arm pose</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true"></a><span class="bu">std::</span>array arm_joint { <span class="fl">0.5</span><span class="bu">f</span>, -<span class="fl">0.3</span><span class="bu">f</span>, -<span class="fl">0.4</span><span class="bu">f</span> };</span></code></pre></div>
<p>You can debug your implementation by controlling the joint states with the UI or modifying them in the animate function.</p>
<p>Take care of ensuring the order of transformations is correct, such that the arm always remains connected, and each joint affects the following joints:</p>
<h1 id="exercise-5-draw-light">Exercise 5: Draw Light</h1>
<p>Implement the <code>drawLight</code> function. This function should draw a small placeholder cube at the light source position so that you can visualize it.</p>
<p>Additionally, make the light position controllable, either via keyboard (WASD) or ImGui controls. Lighting can be toggled with the <code>l/L</code> keys or through the UI.</p>
<p>Lastly, if you haven’t done-so already, add normal information to all your faces in the previous functions and observe how they are properly shaded by the light.</p>
<h1 id="exercise-5-render-a-triangle-mesh">Exercise 5: Render a Triangle Mesh</h1>
<p>Finally, implement the <code>drawMesh</code> function. This function should iterate over the triangles in a mesh and display them separately.</p>
<ul>
<li>Make sure you compute the normals of each face</li>
<li>Try computing a normal per vertex, as the average of the adjacent face normals (you can call <code>glNormal3f</code> before each vertex), this should change how the model is lit</li>
<li>Try loading your own <code>obj</code> model by replacing the provided mesh file</li>
</ul>
</body>
</html>
